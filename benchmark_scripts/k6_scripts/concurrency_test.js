// Generated by Cursor

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Counter, Rate, Trend } from 'k6/metrics';
import { BASE_URL, HEADERS, THRESHOLDS } from './config.js';

// Custom metrics
const successRate = new Rate('success_rate');
const failureRate = new Rate('failure_rate');
const requestDurationTrend = new Trend('request_duration');
const requestsPerSecCounter = new Counter('requests_per_sec');

// Read concurrency from environment variables with defaults
const concurrency = __ENV.CONCURRENCY ? parseInt(__ENV.CONCURRENCY) : 10;
const duration = __ENV.DURATION ? __ENV.DURATION : '30s';
const rampUpTime = __ENV.RAMP_UP ? __ENV.RAMP_UP : '10s';
const endpoints = __ENV.ENDPOINTS ? JSON.parse(__ENV.ENDPOINTS) : ['/plaintext', '/json'];
const targetServer = __ENV.TARGET ? __ENV.TARGET : BASE_URL;

export let options = {
  scenarios: {
    constant_load: {
      executor: 'ramping-vus',
      startVUs: 1,
      stages: [
        { duration: rampUpTime, target: concurrency }, // Ramp-up to the desired concurrency
        { duration: duration, target: concurrency },   // Stay at target concurrency
        { duration: '5s', target: 0 },                 // Ramp-down
      ],
      gracefulRampDown: '5s',
    },
  },
  thresholds: THRESHOLDS,
};

export default function() {
  // Randomly select an endpoint to test
  const endpointIndex = Math.floor(Math.random() * endpoints.length);
  const endpoint = endpoints[endpointIndex];
  
  // Construct full URL
  const url = `${targetServer}${endpoint}`;
  
  // Set headers based on the endpoint
  const headers = { ...HEADERS };
  
  if (endpoint === '/json') {
    headers['Accept'] = 'application/json';
  } else if (endpoint === '/plaintext') {
    headers['Accept'] = 'text/plain';
  }
  
  // Make the request and record the start time
  const startTime = new Date().getTime();
  const response = http.get(url, { headers });
  const endTime = new Date().getTime();
  
  // Record metrics
  const duration = endTime - startTime;
  requestDurationTrend.add(duration);
  requestsPerSecCounter.add(1);
  
  // Basic validation based on endpoint
  let success = false;
  
  if (endpoint === '/json') {
    success = check(response, {
      'status is 200': (r) => r.status === 200,
      'content-type is application/json': (r) => r.headers['Content-Type'] && r.headers['Content-Type'].includes('application/json'),
      'valid json body': (r) => {
        try {
          JSON.parse(r.body);
          return true;
        } catch (e) {
          return false;
        }
      },
    });
  } else if (endpoint === '/plaintext') {
    success = check(response, {
      'status is 200': (r) => r.status === 200,
      'content-type is text/plain': (r) => r.headers['Content-Type'] && r.headers['Content-Type'].includes('text/plain'),
    });
  } else {
    // Generic checks for other endpoints
    success = check(response, {
      'status is 200': (r) => r.status === 200,
    });
  }
  
  // Record success or failure
  successRate.add(success);
  failureRate.add(!success);
  
  // Optional think time between requests (uncomment if needed)
  // sleep(0.1);
}

// Summary output function that will run after the test
// export function handleSummary(data) {
//   console.log('Test completed with the following configuration:');
//   console.log(`- Target Server: ${targetServer}`);
//   console.log(`- Concurrency Level: ${concurrency}`);
//   console.log(`- Test Duration: ${duration}`);
//   console.log(`- Endpoints Tested: ${endpoints.join(', ')}`);
  
//   return {
//     'stdout': JSON.stringify(data),
//     [`results_concurrency_${concurrency}.json`]: JSON.stringify(data),
//   };
// } 